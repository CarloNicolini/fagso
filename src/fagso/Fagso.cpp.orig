/* This file is part of FAGSO, a program to find network partitions
*
*  Copyright (C) 2014-2015 Carlo Nicolini <carlo.nicolini@iit.it>
*
*  Surprise++ is free software; you can redistribute it and/or
*  modify it under the terms of the GNU Lesser General Public
*  License as published by the Free Software Foundation; either
*  version 3 of the License, or (at your option) any later version.
*
*  Alternatively, you can redistribute it and/or
*  modify it under the terms of the GNU General Public License as
*  published by the Free Software Foundation; either version 2 of
*  the License, or (at your option) any later version.
*
*  Surprise++ is distributed in the hope that it will be useful, but WITHOUT ANY
*  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
*  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License or the
*  GNU General Public License for more details.
*
*  You should have received a copy of the GNU Lesser General Public
*  License and a copy of the GNU General Public License along with
*  Surprise++. If not, see <http://www.gnu.org/licenses/>.
*/

#include "Fagso.h"

/**
 * @brief Fagso::Fagso
 * @param Adj
 * @param p
 */
Fagso::Fagso(const GraphAdj &Adj, const Parameters &p)
{
    this->init(Adj,p);
}

/**
 * @brief Fagso::Fagso
 * @param pA
 * @param nrows
 * @param param_map
 */
Fagso::Fagso(double *pA, int nrows, std::map<std::string,std::string> param_map)
{
    this->init(Eigen::Map<GraphAdj>(pA,nrows,nrows), this->params);
    {
        params.sortmethod = SortJaccard;
        params.kfold = 1;
        params.repetitions=1;
        params.firstEdge=-1;
        params.printsolution=false;
        params.saveSolution=false;
        params.initialRandomize=false;
        params.opt = FAGSO;
        params.qualityFunction = MAX_SURPRISE_DISCRETE;
        params.seed = -1;
        params.verbosity = 0;
    }

    this->params.seed = str2int(param_map["seed"]);
    if (this->params.seed == -1)
        randomizeStart();
    this->params.inputGraphFileName = "graph";
    this->params.firstEdge = str2int(param_map["firstedge"]);
    this->params.kfold = str2int(param_map["kfold"]);
    this->params.partitionFileName = "graph";
    this->params.sortmethod = static_cast<SortMethod>(str2int(param_map["sortmethod"]));
    this->params.repetitions = str2int(param_map["repetitions"]);
    this->params.verbosity = str2int(param_map["verbosity"]);
    this->params.saveSolution = str2int(param_map["savesolution"]);
    this->params.qualityFunction = static_cast<QualityFunction>(str2int(param_map["qualityfunction"]));

    FILELog::ReportingLevel() = static_cast<TLogLevel>(params.verbosity);
    for (std::map<string,string>::iterator iter = param_map.begin(); iter!=param_map.end();++iter)
    {
        FILE_LOG(logDEBUG2) << "Parameter \"" << iter->first << "\"=\"" << iter->second << "\"";
    }

    this->run();
}

/**
 * @brief Fagso::init
 * @param Adj
 * @param params
 */
void Fagso::init(const GraphAdj &Adj, const Parameters &params)
{
    this->A = Adj;
    this->params = params;
    this->nVertices = Adj.cols(); // number of nodes
    this->edges = getEdges();
    this->nEdges = this->edges.size();
    // Initialize the disjoint set that contains the solution
    this->ds = DisjointSet(this->A.cols(),params.initialRandomize);
    FILE_LOG(logDEBUG) << "Graph (V,E)=" << nVertices << " " << nEdges;
}

/**
 * @brief Fagso::sumIntraclusterPairsAndEdges
 * @param clu
 * @param mi
 * @param pi
 */
void Fagso::sumIntraclusterPairsAndEdges(const VertexCluster &clu, double *mc, double *pc, double *dc)
{
    int ni = clu.size();
    int submi = 0;
    *pc += static_cast<double>(ni*(ni-1)/2);
    for ( VertexClusterConstIterator iInd1 = clu.begin(); iInd1!=clu.end();++iInd1)
    {
        for ( VertexClusterConstIterator iInd2 = iInd1; iInd2!=clu.end();++iInd2)
            submi += (A.coeffRef(*iInd1,*iInd2)!=0);
        *dc += A.row(*iInd1).sum();
    }
    *mc += submi;
}

#include "AsymptoticEntropy.h"
/**
 * @brief Fagso::getSurprise
 * @param ds
 * @param nNodes
 * @param nEdges
 * @return The surprise of the partition contained in Disjoint set ds with nNodes and nEdges
 */
double Fagso::getSurprise(const DisjointSet &ds, int n, int m)
{
    double p = n*(n-1)/2;
    double mi=0.0;
    double pi=0.0;
    double di=0.0;
    // Iterate over each cluster in the clustering
    for (VertexClusteringConstIterator iter = ds.clustering.begin(); iter!=ds.clustering.end();++iter)
    {
        sumIntraclusterPairsAndEdges(iter->second,&mi,&pi,&di);
    }
    double S = computeSurprise(p,pi,m,mi);
    //cout << "S=" << S << " " << asymptoticEntropy(p,pi,m,mi) << endl;
    //cout << "S=" << S << " " << p << " " << pi << " " << m << " " << mi << endl;
    return S;
}

/**
 * @brief Fagso::getSurprise
 * @param ds
 * @param nNodes
 * @param nEdges
 * @return The surprise of the partition contained in Disjoint set ds with nNodes and nEdges
 */
double Fagso::getAsymptoticSurprise(const DisjointSet &ds, int n, int m)
{
    double p = n*(n-1)/2;
    double mi=0.0;
    double pi=0.0;
    double di=0.0;
    // Iterate over each cluster in the clustering
    for (VertexClusteringConstIterator iter = ds.clustering.begin(); iter!=ds.clustering.end();++iter)
    {
        sumIntraclusterPairsAndEdges(iter->second,&mi,&pi,&di);
    }
    double S = computeAsymptoticSurprise(p,pi,m,mi);
    //cout << "S=" << S << " " << p << " " << pi << " " << m << " " << mi << endl;
    return S;
}

/**
 * @brief Fagso::getSignificance
 * @param ds
 * @param totalNodes
 * @param totalEdges
 * @return
 */
double Fagso::getSignificance(const DisjointSet &ds, int n, int m)
{
    double p = n*(n-1)/2.0;
    double rho = static_cast<double>(m)/p;
    double Significance = 0.0;
    // Iterate over each cluster in the clustering
    for (VertexClusteringConstIterator iter = ds.clustering.begin(); iter!= ds.clustering.end();++iter)
    {
        double mc=0.0; // i-th intracluster edges
        double pc=0; // i-th intracluster pairs
        double dc=0.0;
        sumIntraclusterPairsAndEdges(iter->second,&mc,&pc,&dc);
        double ni = iter->second.size(); // i-th intracluster nodes
        double rhoi = mc/pc;
        if (ni > 1)
        {
            Significance += asymptoticSignificance(ni,rhoi,rho);
        }
    }
    return Significance;
}

/**
 * @brief Fagso::getAsymptoticModularity
 * @param ds
 * @param n
 * @param m
 * @return
 */
double Fagso::getAsymptoticModularity(const DisjointSet &ds, int n, int m)
{
    double asymptModularity = 0.0;
    // Q_kl = sum_c KL(m_c/m || (d_c/2m)^2)
    // For every community
    for (VertexClusteringConstIterator iter = ds.clustering.begin(); iter!= ds.clustering.end();++iter)
    {
        double mc=0.0; // i-th intracluster edges
        double pc=0.0;
        double dc = 0.0; //sum of degrees intracommunity
        // For every vertex in the community
        sumIntraclusterPairsAndEdges(iter->second,&mc,&pc,&dc);
        asymptModularity += mc/double(m) - pow(dc/(2*m),2); // correct definition of modularity
        //asymptModularity += asymptoticModularity(mc,m,dc);
    }
    return asymptModularity;
}

/**
 * @brief Fagso::foldshuffle
 * @param links
 * @param nFolds
 * Shuffle random within each of the nFolds
 */
void Fagso::foldshuffle(LinksList &links, unsigned int nFolds)
{
    unsigned int foldsize = std::div(nEdges,nFolds).quot;
    for (unsigned int i=0; i<nFolds; ++i)
    {
        unsigned int foldStart = (i*foldsize);
        unsigned int foldEnd = ((i+1)*foldsize);
        std::random_shuffle(links.begin()+foldStart, links.begin()+foldEnd);
    }
}

/**
 * @brief Fagso::sortLinks
 * @param links
 * Sort the links in the order specified by the parameters
 */
void Fagso::sortLinks(LinksList &links)
{
    FILE_LOG(logDEBUG1) << "Sorting links, method " << params.sortmethod << ":\"" <<methodnames[params.sortmethod] << "\"";
    if (links.empty())
        return;

    if (this->params.sortmethod == SortRandom)
    {
        std::random_shuffle(links.begin(),links.end());
        return;
    }

    std::vector < pair<double, Link > > linksIndex(links.size());

    for (unsigned int i=0; i<links.size(); ++i)
    {
        pair<double, Link> curLink(0.0,links.at(i));
        int n1 = curLink.second.first;
        int n2 = curLink.second.second;
        switch (this->params.sortmethod)
        {
        case SortAverageDegree:
        {
            curLink.first = averageDegreeIndex(A, n1, n2);
            break;
        }
        case SortSorensen:
        {
            curLink.first = sorensenIndex(A, n1, n2);
            break;
        }
        case SortJaccard:
        {
            curLink.first = jaccardIndex(A, n1, n2);
            break;
        }
        case SortCommonNeighbors:
        {
            curLink.first = commonNeighbors(A, n1, n2);
            break;
        }
        case SortAdamicAdar:
        {
            curLink.first = adamicAdarIndex(A, n1, n2);
            break;
        }
        case SortHubDepressed:
        {
            curLink.first = hubDepressedIndex(A, n1, n2);
            break;
        }
        case SortHubPromoted:
        {
            curLink.first = hubPromotedIndex(A, n1, n2);
            break;
        }
        case SortResourceAllocation:
        {
            curLink.first = resourceAllocationIndex(A, n1, n2);
            break;
        }
        case SortPreferentialAttachment:
        {
            curLink.first = preferentialAttachmentIndex(A, n1, n2);
            break;
        }
        case SortSalton:
        {
            curLink.first = saltonIndex(A, n1, n2);
            break;
        }
        case SortLeichtHolmeNewman:
        {
            curLink.first  = leightHolmeNewmanIndex(A, n1, n2);
            break;
        }
        case SortJaccardNormalized:
        {
            curLink.first = jaccardNormalized(A,n1,n2);
            break;
        }
        case SortCosine:
        {
            curLink.first = cosineIndex(A,n1,n2);
            break;
        }
        case SortRandom:
        case SortEdgeLength:
        case num_values:
        {
            break;
        }

        }
        linksIndex.at(i) = curLink;
    }

    if (this->params.sortmethod == SortEdgeLength )
    {
        MatrixXf Coords = loadCoordinates(params.coordinateFileName);
        if (Coords.rows() != this->A.rows())
            throw std::runtime_error("Mismatch between graph and coordinates file. Must have the same number of rows.");
        for (unsigned int i=0; i<linksIndex.size();++i)
        {
            int n1 = linksIndex[i].second.first;
            int n2 = linksIndex[i].second.second;
            linksIndex[i].first *= (Coords.row(n1)-Coords.row(n2)).squaredNorm();
        }
        std::sort(linksIndex.begin(),linksIndex.end(),randomTieBreak);
    }
    else
    {
        std::sort(linksIndex.begin(),linksIndex.end(),randomTieBreak);
    }

    // Change the first edge to redirect the search
    pair<double, Link> x = linksIndex.at(params.firstEdge%linksIndex.size());
    std::swap(x,linksIndex.front());

    // Repopulate the links
    for (unsigned int i=0; i<linksIndex.size();++i)
    {
        links[i].first = linksIndex[i].second.first;
        links[i].second = linksIndex[i].second.second;
    }

    // Reshuffle in folds
    if (params.kfold!=1)
    {
        FILE_LOG(logDEBUG1) << "Shuffling links within "<< params.kfold << " folds";
        foldshuffle(links,params.kfold);
    }

    FILE_LOG(logDEBUG1) << "Sorting links finished.";
}

/**
 * @brief Fagso::getMembership
 * @return
 */
std::vector<int> Fagso::getMembership()
{
    std::vector<int> memb(ds.membership.size());
    for (std::map<int,int>::iterator iter = ds.membership.begin(); iter!=ds.membership.end();++iter)
    {
        memb.at(iter->first) = iter->second;
    }
    return memb;
}

/**
 * @brief Fagso::getEdges
 * @return
 */
LinksList Fagso::getEdges()
{
    LinksList edges;
    for (int i=0; i<this->nVertices; ++i)
    {
        for (int j=i+1; j<nVertices; j++)
        {
            if (A.coeffRef(i,j)!=0)
            {
                edges.push_back(pair<int,int>(i,j));
            }
        }
    }
    return edges;
}

/**
 * @brief Fagso::runFagsoSingleIter
 * @return
 */
pair<double,DisjointSet> Fagso::runFagsoSingleIter()
{
    int nVertices = A.cols(); // number of nodes
    DisjointSet ds(nVertices, this->params.initialRandomize);
    int iteration=0;
    LinksList edges = getEdges();
    sortLinks(edges);
    double qual=std::numeric_limits<double>::min();
    while (iteration < nEdges)
    {
        Link e = edges[iteration];
        if (ds.membership[e.first] != ds.membership[e.second]) // keep only intercluster edges
        {
            ds.add(e.first,e.second);
            double curQual = 0.0;
            switch (params.qualityFunction)
            {
            case MAX_SURPRISE_DISCRETE:
            {
                curQual = getSurprise(ds,nVertices,nEdges);
                break;
            }
            case MAX_SIGNIFICANCE_ASYMPT:
            {
                curQual = getSignificance(ds,nVertices,nEdges);
                break;
            }
            case MAX_SURPRISE_ASYMPT:
            {
                curQual = getAsymptoticSurprise(ds,nVertices,nEdges);
                break;
            }
            case MAX_MODULARITY_ASYMPT:
            {
                curQual = getAsymptoticModularity(ds,nVertices,nEdges);
                break;
            }
            }
            if ( curQual > qual )
            {
                qual = curQual;
            }
            else
            {
                ds.undo();
            }
        }
        ++iteration;
    }

    ds.sortBySize();
    return pair<double,DisjointSet>(qual,ds);
}



/**
 * @brief Fagso::run
 * Run the fagso algorithm and keep the partition with highest Surprise
 */
void Fagso::run()
{
    FILE_LOG(logDEBUG) << "Running Fagso: maximizing " << qualityFunctionames[params.qualityFunction];
    double quality=0;
    for (unsigned int i=0; i<params.repetitions; i++)
    {
        FILE_LOG(logDEBUG1) << "Running Fagso iteration " << i;
        pair<double, DisjointSet> sol = runFagsoSingleIter();
        if (sol.first > quality)
        {
            quality = sol.first;
            this->ds = sol.second;
            if (params.saveSolution)
            {
                FILE_LOG(logDEBUG1) << "Solution saved to = " << savestring(params,quality);
                this->ds.save(savestring(params,quality));
            }
        }
        FILE_LOG(logDEBUG1) << "Best S=" << quality;
    }

    if (params.printsolution)
        this->ds.print(cout);

    this->finalSurprise = getSurprise(ds,nVertices,nEdges);
    this->finalSignificance  = getSignificance(ds,nVertices,nEdges);
    this->finalAsymptoticSurprise = getAsymptoticSurprise(ds,nVertices,nEdges);
    this->finalAsymptoticModularity = getAsymptoticModularity(ds,nVertices,nEdges);

    FILE_LOG(logINFO) << "Final Surprise=" << finalSurprise;
    FILE_LOG(logINFO) << "Final Significance=" << finalSignificance;
    FILE_LOG(logINFO) << "Final AsymptoticSurprise=" << finalAsymptoticSurprise;
    FILE_LOG(logINFO) << "Final AsymptoticModularity=" << finalAsymptoticModularity;
    if (params.saveSolution)
    {
        FILE_LOG(logINFO) << "Solution saved to = " << savestring(params,quality);
    }
}

/**
 * @brief Fagso::getFinalSignificance
 * @return
 */
double Fagso::getFinalSignificance() const
{
    return finalSignificance;
}

/**
 * @brief Fagso::getFinalSurprise
 * @return
 */
double Fagso::getFinalSurprise() const
{
    return finalSurprise;
}

/**
 * @brief Fagso::getFinalAsymptoticSurprise
 * @return
 */
double Fagso::getFinalAsymptoticSurprise() const
{
    return finalAsymptoticSurprise;
}

/**
 * @brief Fagso::getFinalAsymptoticModularity
 * @return
 */
double Fagso::getFinalAsymptoticModularity() const
{
    return finalAsymptoticModularity;
}
